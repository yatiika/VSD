Introduction to timing .lib 
Day 2.1 : Introduction to .lib
Name of the library is "sky130_fd_sc_hd_tt_025C_1v80", the information we get from decoding this name about this library 
It is 130 nm library.
tt= Typical (can be slow , fast or typical)
025C: temperature 
1v: Voltage

P V T in library name stands for :
P: Process (Variations due to fabrication)
V : Voltage (Variations due to voltage)
T: Temperature (Variations due to temperature , silicon is sensitive to temperature)
These are essential for a design to work
They determine how silicon will work fast or slow.
The same circuit with different variations should work in all conditions.
This library is using cmos technology.
Delay model is table_lookup
it specifies unit of :
      time: nanosecond 
      voltage:volt
      power: Nanowolt
      current: miliampere
      resistance : kiloohm
      capacitance : picofarad 
.lib contains alot of cells that are defined as "sky130_fd_sc_hd_a2111o_1": which stands for 2 input AND into first input of 4 input OR. 
It has 32 combinations and values of each pin are also defined like capacitance, clock,direction,internal power.
we can open the verilog model for the same .
The area increases with the increaseing name numbering , as no. of transistors incresases. 

large cell means that that cell is employing wider transisator that will be faster but area and power will be more, narrow cells power and area will be less.

Day 2.2 : Hierarchical vs Flat synthesis
Flat Synthesis: treating the entire design as one block, without dividing it into smaller parts.
this have better logic optimization 
it result in small area and faster performance 
This is not suitable for big designs as debugging is difficult 
Hierarchical Synthesis: design divided into multiple modules written in RTL.
It preserves module boundraries . every module is synthesised individually.
Better for large and complex designs 
Uses larger area and slower performance as compared to flat synthesis.

Multiple module structure description :

Sub module 2 is OR gate 
Sub module 1 is AND gate 
3 inputs a,b,c and output is Y 
AND gate : input a,b 
OR gate: input c, output of AND gate
Y : output of OR gate 
Using NAND gate we get stacked NMOS  which is good.
Where as using NOR INVERTOR we get stacked PMOS which is bad as the mobility is poor and to improve this we need to create a wide cell.
In this cell defining code the hericarchy is preserved.

Why sub module level is synthesised ?
It means synthesising smaller part of a design instead of whole top level design at once.
It is done when we have multiple instances of same module. 
It uses divide and conquer statergy.


Day 2.3 : Various Flop coding Styles and Optimization 
Why flip flop coding styles
Combinational circuits do not remember anything.
We want a circuit that can store data, react over time, or synchronize with a clock, we need flip-flops (flops).
Flip Flop: basic memory element which can store only 1 bit 0 or 1.
It remembers value and updates the stored value on clock edge hence called clock controlled memory.
common type of clock is D flip flop.
We have 4 types :
1) Flip-Flop with Asynchronous Reset:
Output is reset to 0 immediately when the reset signal is high.
Does NOT wait for the clock.
Commonly used for resetting all registers at power-on.
code:
module dff_async_reset (
    input wire clk,
    input wire reset,  // asynchronous reset
    input wire d,
    output reg q
);
    always @(posedge clk or posedge reset) begin
        if (reset)
            q <= 1'b0;
        else
            q <= d;
    end
endmodule

2) Flip-Flop with Asynchronous Set: 
Output is set to 1 immediately when the set signal is high.
Does NOT wait for the clock.
Used when a signal must quickly go high regardless of the clock.
Code:
module dff_async_set (
    input wire clk,
    input wire set,    // asynchronous set
    input wire d,
    output reg q
);
    always @(posedge clk or posedge set) begin
        if (set)
            q <= 1'b1;
        else
            q <= d;
    end
endmodule

3) Flip-Flop with Synchronous Set:
Output is set to 1, but only on clock edge when set = 1.
Ignores set signal outside of the clock edge.
Used in state machines or controlled data latching.
Code:
module dff_sync_set (
    input wire clk,
    input wire set,    // synchronous set
    input wire d,
    output reg q
);
    always @(posedge clk) begin
        if (set)
            q <= 1'b1;
        else
            q <= d;
    end
endmodule

4) Flip-Flop with Synchronous Reset:
Output is reset to 0, but only on clock edge when reset = 1.
More timing-controlled reset behavior.
Common in pipelining and data path control.
Code:
module dff_sync_reset (
    input wire clk,
    input wire reset,   // synchronous reset
    input wire d,
    output reg q
);
    always @(posedge clk) begin
        if (reset)
            q <= 1'b0;
        else
            q <= d;
    end
endmodule

Asynchronus : Acts instantly, doesn't wait for clock.
Synchronous : Acts only with the clock edge.

Flop synthesis 
We observe different patterns in waves in Flop asynchronus set,Flop asynchronus reset, Flop synchronus reset,Flop synchronus set.
We synthesis circuit of all 4 flip flop(Flop asynchronus set,Flop asynchronus reset, Flop synchronus reset,Flop synchronus set) in yosys and get a logic diagram of the same.

Interesting optimization 
A with 3 bit input into mux Y = 2* A gives output Y 4 bit input
we tried to code and get the same logic diagram which we were sucessful at.

we take 2 bit number and y is a 6 bit number. 
a*9 =y 
a*[8+1] =y 
8a + a = y 
we get output as "aa" and "9".


